[
["logical-statements.html", "Chapter 4 Logical Statements 4.1 Key Concepts 4.2 Operators 4.3 Selector Vectors 4.4 Usefulness of Selector Vectors 4.5 Compound Logical Statements 4.6 NAs in Logical Statements 4.7 Subsets", " Chapter 4 Logical Statements th { text-align: left; } td { text-align: left; } 4.1 Key Concepts Figure 4.1: Logical statements define group membership Logical statements are used to translate regular language into computer code. Many of our data analysis problems start by defining our sub-groups of interest. What percentage of men over 30 are bald? these &lt;- gender == &quot;male&quot; &amp; age &gt; 30 &amp; hair == FALSE mean( these ) Do bearded men earn more than men without beards? We need to make sure statements are correct. For example, the complement of “men with beards” is not men without beards, it is men without beards OR women (with or without beards). Figure 4.2: Compound statements can be tricky bearded.men &lt;- gender == &quot;male&quot; &amp; beard == TRUE proper.gentlemen &lt;- gender == &quot;male&quot; &amp; beard == FALSE mean( salary[ bearded.men ] ) mean( salary[ ! bearded.men ] ) # this is incorrect !!! mean( salary[ proper.gentlemen ] ) 4.2 Operators Logical operators are the most basic type of data programming and the core of many types of data analysis. Most of the time we are not conducting fancy statistics, we just want to identify members of a group (print all of the females from the study), or describe things that belong to a subset of the data (compare the average price of houses with garages to houses without garages). In order to accomplish these simple tasks we need to use logic statements. A logic statement answers the question, does an observation belong to a group. Many times groups are simple. Show me all of the professions that make over $100k a year, for example. Sometimes groups are complex. Identify the African American children from a specific zip code in Chicago that live in households with single mothers. You will use nine basic logical operators: Operator Description &lt; less than &lt;= less than or equal to &gt; greater than &gt;= greater than or equal to == exactly equal to != not equal to x | y x OR y x &amp; y x AND y ! opposite of [ ] subset Logical operators create logical vectors, a vector that contains only TRUE or FALSE. The TRUE means that the observation belongs to the group, FALSE means it does not. x1 &lt;- c( 7, 9, 1, 2 ) x1 &gt; 7 ### [1] FALSE TRUE FALSE FALSE x1 &gt;= 7 ### [1] TRUE TRUE FALSE FALSE x1 == 9 | x1 == 1 ### [1] FALSE TRUE TRUE FALSE gender &lt;- c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;) gender == &quot;female&quot; ### [1] FALSE FALSE TRUE TRUE Note that the logical statement for “equals” is written with two equal signs. This is important to remember, because using a single equal sign can introduce subtle errors into your analysis. x1 &lt;- c( 7, 9, 1, 2 ) x1 == 9 ### [1] FALSE TRUE FALSE FALSE x1 = 9 # don&#39;t use a single equals operator! it overwrites your variable x1 ### [1] 9 We can write compound logical statements using the AND and OR operators: gender &lt;- c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;) study.group &lt;- c(&quot;treatment&quot;,&quot;control&quot;,&quot;treatment&quot;,&quot;control&quot;) gender == &quot;female&quot; &amp; study.group == &quot;treatment&quot; ### [1] FALSE FALSE TRUE FALSE gender == &quot;female&quot; | study.group == &quot;treatment&quot; ### [1] TRUE FALSE TRUE TRUE 4.3 Selector Vectors Note that we use operators to create logical vectors where TRUE designates observation that belong to the defined group, and FALSE designates observations outside the group. The term “selector vector” is a useful way to remember this purpose. When you are doing analysis, you select specific observaions to form a group, and you can name gender group strength frank male treat 27 wanda female treat 43 sanjay male control 19 nancy female control 58 these.female &lt;- dat$gender == &quot;female&quot; sum( these.female ) # number of women in the study ### [1] 2 mean( these.female ) # proportion of the study that is women ### [1] 0.5 dat[ these.female , ] # all data belonging to women ### name gender group strength ### 2 wanda female treat 43 ### 4 nancy female control 58 mean( dat$strength[ these.female ] ) # average outcome for women in the study ### [1] 50.5 I will consistently name my logical vectors “these.GROUP” throughout the chapters, where GROUP represents the group label. For example, I selected women above, so the selector vector is called “these.female”. 4.4 Usefulness of Selector Vectors Selector vectors, i.e. logical vectors that were created by defining a group, have three main uses in our analysis. ONE: Logical vectors give us an easy way to count things within defined groups. We can apply a sum() function to a logical vector, and the result will be a tally of all of the TRUE cases. The mean() function will give us the proportion of the sample that belongs to our defined group. # how many females do we have in our study? sum( gender == &quot;female&quot; ) ### [1] 2 # how many females do we have in our treatment group? sum( gender == &quot;female&quot; &amp; study.group == &quot;treatment&quot; ) ### [1] 0 # what proportion of our study are men? mean( gender == &quot;male&quot; ) ### [1] 0.5 TWO: We can create a selector variable that is used for subsets. A selector vector used in a subset operator will drop all observations that are FALSE, isolating data belonging to the group: these.female &lt;- gender == &quot;female&quot; name[ these.female ] ### [1] &quot;wanda&quot; &quot;nancy&quot; strength[ these.female ] ### [1] 43 58 Or we can create a subset of the full dataset: dat[ these.female , ] name gender group strength 2 wanda female treat 43 4 nancy female control 58 THREE: We use selector variables to replace observations with new values using the assignment operator. This is similar to a find and replace operation. animals &lt;- c( &quot;mole&quot;, &quot;mouse&quot;, &quot;shrew&quot;, &quot;mouse&quot;, &quot;rat&quot;, &quot;shrew&quot; ) # the lab assistant incorrectly identified the shrews animals ### [1] &quot;mole&quot; &quot;mouse&quot; &quot;shrew&quot; &quot;mouse&quot; &quot;rat&quot; &quot;shrew&quot; animals[ animals == &quot;shrew&quot; ] &lt;- &quot;possum&quot; animals ### [1] &quot;mole&quot; &quot;mouse&quot; &quot;possum&quot; &quot;mouse&quot; &quot;rat&quot; &quot;possum&quot; We don’t know if linda received the treatment: name study.group adam treatment jamal control linda treatment sriti control study.group[ name == &quot;linda&quot; ] &lt;- NA study.group ### [1] &quot;treatment&quot; &quot;control&quot; NA &quot;control&quot; The ! operator is a special case, where it is not used to define a new logical vector, but rather it swaps the values of an existing logical vector. x1 &lt;- c(7,9,1,2) these &lt;- x1 &gt; 5 these ### [1] TRUE TRUE FALSE FALSE ! these ### [1] FALSE FALSE TRUE TRUE ! TRUE ### [1] FALSE ! FALSE ### [1] TRUE 4.5 Compound Logical Statements We can combine multiple logical statements using the AND, OR, and NOT operators ( &amp;, |, ! ). This functionality gives us an incredible ability to specify very granular groups within our analysis. This will be important as we begin to construct analysis in a way that we search for apples to apples comparisons within our data in order to make inferences about program effectiveness. These statements require some precision, however. Use care when applying that AND, OR, and NOT operators as to not include unintended data in your sample. In the example above, the statement “NOT bearded men” does not mean men without beards. It means all people outside of the category of men without beards (the “complement”), which includes women with or without beards as well. ! ( gender == &quot;male&quot; &amp; beard == TRUE ) Also note that parentheses matter. Compare this statement to the statement above: ! gender == &quot;male&quot; &amp; beard == TRUE Because we excluded the parentheses this statement now defines the group “NOT men AND with beards”, or bearded women. Figure 4.3: Examples of group construction with compound statements 4.6 NAs in Logical Statements Recall that missing values are an extremely important concept in statistics. If one-third of our survey sample reports that they never smoked pot, one-third reports they have smoked pot, and one-third did not answer the question, then what do we report for the proportion of the population that has smoked pot? We might prefer to be cautious and count only the people that have confirmed they have smoked pot, resulting in an estimate of 33.3%. If we throw out the missing data, then 50% of respondents have smoked pot. If we assume those that refuse to answer have likely smoked pot, our estimate might be 66.6% of the sample. These different results are a function of how we treat the missing data in our survey, so it is important that we can keep track of missing values, especially during subset operations. Note how NAs effect compound logical statements: TRUE &amp; TRUE ### [1] TRUE TRUE &amp; FALSE ### [1] FALSE TRUE &amp; NA ### [1] NA FALSE &amp; NA ### [1] FALSE To make sense of these rules consider the following: If one condition is already FALSE, the missing value does not matter because under the &amp; condition BOTH must be TRUE for the observation to belong to our defined group. After we know that one of the conditions is FALSE the missing value is irrelevant. For example, if we want to select all women in the treatment group, and we have a man with an unclear treatment group status, he is still excluded from the group because he is a man. On the other hand, if one condition is TRUE, and another is NA, R does not want to throw out the data because the state of the missing value is unclear. As a result, it will preserve the observation, but it will replace all of the data with missing values to signal the lack of certainty associated with that observation. name gender group strength frank male treat 27 wanda female treat 43 sanjay male control 19 nancy female control 58 keep.these &lt;- c(T,F,NA,F) dat[ keep.these , ] ### name gender group strength ### 1 frank male treat 27 ### NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA To remove these rows with missing values in your selector vector, replace all NAs with FALSE: keep.these[ is.na(keep.these) ] &lt;- FALSE dat[ keep.these , ] ### name gender group strength ### 1 frank male treat 27 4.7 Subsets The subset operators [ ] are one of the most common you will use in R. The primary rule of subsets is to use a data operator to create a logical selector vector, and use that to generate subsets. Any observation that corresponds to TRUE will be retained, any observation that corresponds to FALSE will be dropped. For vectors, you need to specify a single dimension. name gender group strength frank male treat 27 wanda female treat 43 sanjay male control 19 nancy female control 58 these.treat &lt;- dat$group == &quot;treat&quot; name[ these.treat ] ### [1] &quot;frank&quot; &quot;wanda&quot; strength[ these.treat ] ### [1] 27 43 For data frames, you need two dimensions (rows and columns). The two dimensions are seperated by a comma, and if you leave one blank you will not drop anything. dat[ row position , column position ] these.control &lt;- dat$group == &quot;control&quot; dat[ these.control , ] # all data in the control group ### name gender group strength ### 3 sanjay male control 19 ### 4 nancy female control 58 dat[ , c(&quot;name&quot;,&quot;gender&quot;) ] # select two columns of data ### name gender ### 1 frank male ### 2 wanda female ### 3 sanjay male ### 4 nancy female # to keep a subset as a separate dataset dat.women &lt;- dat[ dat$gender == &quot;female&quot; , ] dat.women ### name gender group strength ### 2 wanda female treat 43 ### 4 nancy female control 58 Note the rules listed above about subsetting factors. After applying a subset, they will retain all of the original levels, even when they are not longer useful. You need to drop the unused levels if you would like them to be omitted from functions that use the factor levels for analysis. df &lt;- data.frame( letters=LETTERS[1:5], numbers=seq(1:5) ) levels( df$letters ) ### [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; sub.df &lt;- df[ 1:3, ] sub.df$letters ### [1] A B C ### Levels: A B C D E levels( sub.df$letters ) ### [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; droplevels( sub.df$letters ) ### [1] A B C ### Levels: A B C sub.df$letters &lt;- droplevels( sub.df$letters ) "]
]
