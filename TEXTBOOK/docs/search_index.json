[
["data-structures.html", "Chapter 2 Data Structures 2.1 Vectors 2.2 Casting 2.3 The Combine Function 2.4 Numeric Vectors 2.5 Character Vectors 2.6 Logical Vectors 2.7 Factors 2.8 Generating Vectors", " Chapter 2 Data Structures 2.1 Vectors Vectors are the building blocks of data programming in R, so they are extremely important concepts. Very loosely speaking a vector is a set of numbers, words, or other values: [ 1, 2, 3] [ apple, orange, pear ] [ TRUE, FALSE, FALSE ] In social sciences, a vector usually represents a variable in a dataset. There are four primary vector types (“classes”) in R: Class Description numeric Typical variable of only numbers character A vector of letters or words, always enclosed with quotes factor Categories which represent groups, like treatment and control logical A vector of TRUE and FALSE to designate which observations fit a criteria Each vector or dataset has a “class” that tells R the data type. These different vectors can be combined into three different types of datasets (data frames, matrices, and lists), which will be discussed below. x1 &lt;- c(167,185,119,142) x2 &lt;- c(&quot;adam&quot;,&quot;jamal&quot;,&quot;linda&quot;,&quot;sriti&quot;) x3 &lt;- factor( c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;) ) x4 &lt;- c( &quot;treatment&quot;,&quot;control&quot;,&quot;treatment&quot;,&quot;control&quot; ) x5 &lt;- x4 == &quot;treatment&quot; dat &lt;- data.frame( name=x2, sex=x3, treat=x4, is.treat=x5, strength=x1 ) name sex treat is.treat strength adam male treatment TRUE 167 jamal male control FALSE 185 linda female treatment TRUE 119 sriti female control FALSE 142 R keeps track of the data type of each object, which can be ascertained using the class() function. class( x ) #&gt; $name #&gt; [1] &quot;character&quot; #&gt; #&gt; $sex #&gt; [1] &quot;factor&quot; #&gt; #&gt; $treat #&gt; [1] &quot;character&quot; #&gt; #&gt; $is.treat #&gt; [1] &quot;logical&quot; #&gt; #&gt; $strength #&gt; [1] &quot;numeric&quot; class( dat ) #&gt; [1] &quot;data.frame&quot; 2.1.1 Common Functions for Vectors You will spend a lot of time creating data vectors, transforming variables, generating subsets, cleaning data, and adding new observations. These are all accomplished through operators (commands) that act on vectors. We often need to know how many elements belong to a vector, which we find with the length() function. x1 #&gt; [1] 167 185 119 142 length( x1 ) #&gt; [1] 4 2.2 Casting You can easily move from one data type to another by casting a specific type as another type: x &lt;- 1:5 x #&gt; [1] 1 2 3 4 5 as.character(x) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; y &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE) y #&gt; [1] TRUE FALSE TRUE TRUE FALSE as.numeric( y ) #&gt; [1] 1 0 1 1 0 as.character( y ) #&gt; [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;TRUE&quot; &quot;TRUE&quot; &quot;FALSE&quot; But in some cases it might not make sense to cast one variable type as another. z &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) z #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; as.numeric( z ) #&gt; [1] NA NA NA Casting will often be induced when you try to combine different types of data. For example, when you add a character element to a numeric vector, the whole vector will be cast as a character vector. x10 &lt;- 1:5 x10 #&gt; [1] 1 2 3 4 5 # a vector can only have one data type x11 &lt;- c( x10, &quot;a&quot;) x11 # all numbers silently recast as characters #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;a&quot; When you read data in from outside sources, the input functions often will cast numeric vectors as factors if they contain a low number of elements. See the section on factors below for special instrucdtions on moving from factors to numeric vectors. 2.3 The Combine Function We often need to combine several elements into a single vector, or two vectors to form one. This is done using the c() function. c(1,2,3) #&gt; [1] 1 2 3 c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; x &lt;- 1:5 y &lt;- 10:15 z &lt;- c(x,y) z #&gt; [1] 1 2 3 4 5 10 11 12 13 14 15 c(z,&quot;a&quot;) # combining data types #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; &quot;a&quot; 2.4 Numeric Vectors There are some specific things to note about each vector type. Math operators will only work on numeric vectors. summary( x1 ) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 119.0 136.2 154.5 153.2 171.5 185.0 Note that if we try to run this mathematicl function we get an error: sum( x2 ) # Error in sum(x2) : invalid &#39;type&#39; (character) of argument Many functions in R are sensitive to the data type of vectors. Mathematical functions, for example, do not make sense when applied to text (character vectors). In many cases R will give an error. In some cases R will silently re-cast the variable, then perform the operation. Be watchful for when silent re-casting occurs because it might have unwanted side effects, such as deleting data or re-coding group levels in the wrong way. 2.4.1 Integers Are Simple Numeric Vectors The integer vector is a special type of numeric vector. It is used to save memory since integers require less space than numbers that contain decimals points (you need to allocate space for the numbers to the left and the numbers to the right of the decimal). Google “computer memory allocation” if you are interested in the specifics. If you are doing advanced programming you will be more sensitive to memory allocation and the speed of your code, but in the intro class we will not differentiate between the two types of number vectors. In most cases they result in the same results, unless you are doing advanced numerical analysis where rounding errors matter. n &lt;- 1:5 n #&gt; [1] 1 2 3 4 5 class( n ) #&gt; [1] &quot;integer&quot; n[ 2 ] &lt;- 2.01 n # all elements converted to decimals #&gt; [1] 1.00 2.01 3.00 4.00 5.00 class( n ) #&gt; [1] &quot;numeric&quot; 2.5 Character Vectors The most important rule to remember with this data type: when creating character vectors, all text must be enclosed by quotation marks. c( &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ) # this works #&gt; [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # c( a, b, c ) # this doesn&#39;t work # Error: object &#39;a&#39; not found When you type characters surrounded by quotes then R knows you are creating new text (“strings” in programming speak). When you type characters that are not surrounded by quotes, R thinks that you are looking for an object in the environment, like the variables we have already created. It gets confused when it doesn’t find the object that you typed. In generate, you will use quotes when you are creating character vectors, and for arguments in functions. You do not use quotes when you are referencing an active object. ls() # these are all of the active objects #&gt; [1] &quot;dat&quot; &quot;n&quot; &quot;x&quot; &quot;x1&quot; &quot;x10&quot; &quot;x11&quot; &quot;x2&quot; &quot;x3&quot; &quot;x4&quot; &quot;x5&quot; &quot;y&quot; #&gt; [12] &quot;z&quot; &quot;x1&quot; #&gt; [1] &quot;x1&quot; x1 #&gt; [1] 167 185 119 142 plot( rnorm(5), col=&quot;blue&quot;, pch=19, cex=4 ) # text used for color argument, use quotes # what if we want colors that represent groups in our data plot( 1:4, x1, col=x3, pch=19, cex=4 ) # object used for color argument, no quotes Recall that x3 is the sex of study participants, so the different colors represent the different genders in the study. 2.6 Logical Vectors Logical vectors are collections of a set of TRUE and FALSE statements. Logical statements allow us to define groups based upon criteria, then decide whether observations belong to the group. See the section on operators below for a complete list of logical statements. Logical vectors are important because organizing data into these sets is what drives all of the advanced data analytics (set theory is at the basis of mathematics and computer science). dat #&gt; name sex treat is.treat strength #&gt; 1 adam male treatment TRUE 167 #&gt; 2 jamal male control FALSE 185 #&gt; 3 linda female treatment TRUE 119 #&gt; 4 sriti female control FALSE 142 dat$name == &quot;sriti&quot; #&gt; [1] FALSE FALSE FALSE TRUE dat$sex == &quot;male&quot; #&gt; [1] TRUE TRUE FALSE FALSE dat$strength &gt; 180 #&gt; [1] FALSE TRUE FALSE FALSE Typically logical vectors are used in combination with subset operators to identify specific groups in the data. dat #&gt; name sex treat is.treat strength #&gt; 1 adam male treatment TRUE 167 #&gt; 2 jamal male control FALSE 185 #&gt; 3 linda female treatment TRUE 119 #&gt; 4 sriti female control FALSE 142 # isolate data on all of the females in the dataset dat[ dat$sex == &quot;female&quot; , ] #&gt; name sex treat is.treat strength #&gt; 3 linda female treatment TRUE 119 #&gt; 4 sriti female control FALSE 142 When defining logical vectors, you can use the abbreviated versions of T for TRUE and F for FALSE. z1 &lt;- c(T,T,F,T,F,F) z1 #&gt; [1] TRUE TRUE FALSE TRUE FALSE FALSE Note how NAs affect complex logical statements: TRUE &amp; TRUE #&gt; [1] TRUE TRUE &amp; FALSE #&gt; [1] FALSE TRUE &amp; NA #&gt; [1] NA FALSE &amp; NA #&gt; [1] FALSE If one condition is TRUE, and another is NA, R does not want to throw out the data because the state of the missing value is unclear. As a result, it will preserve the observation, but it will replace all of the data with missing values: dat #&gt; name sex treat is.treat strength #&gt; 1 adam male treatment TRUE 167 #&gt; 2 jamal male control FALSE 185 #&gt; 3 linda female treatment TRUE 119 #&gt; 4 sriti female control FALSE 142 keep.these &lt;- c(T,F,NA,F) dat[ keep.these , ] #&gt; name sex treat is.treat strength #&gt; 1 adam male treatment TRUE 167 #&gt; NA &lt;NA&gt; &lt;NA&gt; &lt;NA&gt; NA NA To remove these rows, replace all NAs in your selector vector with FALSE: keep.these[ is.na(keep.these) ] &lt;- FALSE dat[ keep.these , ] #&gt; name sex treat is.treat strength #&gt; 1 adam male treatment TRUE 167 2.7 Factors When there are categorical variables within our data, or groups, then we use a special vector to keep track of these groups. We could just use numbers (1=female, 0=male) or characters (“male”,“female”), but factors are useful for two reasons. First, it saves memory. Text is very “expensive” in terms of memory allocation and processing speed, so using simpler data structure makes R faster. Second, when a variable is set as a factor, R recognizes that it represents a group and it can deploy object-oriented functionality. When you use a factor in analysis, R knows that you want to split the analysis up by groups. height &lt;- c( 70, 68, 62, 64, 72, 69, 58, 63 ) strength &lt;- c(167,185,119,142,175,204,124,117) sex &lt;- factor( c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;,&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot; ) ) plot( height, strength ) # simple scatter plot plot( sex, strength ) # box and whisker plot Factors are more memory efficient than character vectors because they store the underlying data as a numeric vector instead of a categorical (text) vector. Each group in the data is assigned a number, and when printing items the program only has to remember which group corresponds to which number: sex #&gt; [1] male male female female male male female female #&gt; Levels: female male as.numeric( sex ) #&gt; [1] 2 2 1 1 2 2 1 1 # male = 2 # female = 1 If you print a factor, the computer just replaces each category designation with its name (2 would be replaced with “male” in this example). These replacements can be done in real time without clogging the memory of your computer as they don’t need to be saved. In some instances a categorical variable might be represented by numbers. For example, grades 9-12 for high school kids. The very important rule to remember with factors is you can’t move directly from the factor to numeric using the as.numeric() casting function. This will give you the underlying data structure, but will not give you the category names. To get these, you need the as.character casting function. grades &lt;- sample( x=9:12, size=10, replace=T ) grades #&gt; [1] 10 12 11 9 12 12 11 12 9 9 grades &lt;- as.factor( grades ) grades #&gt; [1] 10 12 11 9 12 12 11 12 9 9 #&gt; Levels: 9 10 11 12 as.numeric( grades ) #&gt; [1] 2 4 3 1 4 4 3 4 1 1 as.character( grades ) #&gt; [1] &quot;10&quot; &quot;12&quot; &quot;11&quot; &quot;9&quot; &quot;12&quot; &quot;12&quot; &quot;11&quot; &quot;12&quot; &quot;9&quot; &quot;9&quot; # to get back to the original numeric vector as.numeric( as.character( grades )) #&gt; [1] 10 12 11 9 12 12 11 12 9 9 Note that when subsetting a factor, it will retain all of the original levels, even when they are not in use. In this example, there are 37 teams in the Lahman dataset (some of them defunct) and 16 teams in the National League in 2002. But after applying the year and league subsets you will still have 37 levels. # there are only 16 teams in the NL in 2002 sals.2002 &lt;- Salaries [Salaries$yearID==&quot;2002&quot;, ] nl.sals &lt;- sals.2002 [ sals.2002$lgID == &quot;NL&quot;,] levels( nl.sals$teamID ) #&gt; [1] &quot;ANA&quot; &quot;ARI&quot; &quot;ATL&quot; &quot;BAL&quot; &quot;BOS&quot; &quot;CAL&quot; &quot;CHA&quot; &quot;CHC&quot; &quot;CHN&quot; &quot;CHW&quot; &quot;CIN&quot; #&gt; [12] &quot;CLE&quot; &quot;COL&quot; &quot;DET&quot; &quot;FLO&quot; &quot;HOU&quot; &quot;KCA&quot; &quot;KCR&quot; &quot;LAA&quot; &quot;LAD&quot; &quot;LAN&quot; &quot;MIA&quot; #&gt; [23] &quot;MIL&quot; &quot;MIN&quot; &quot;ML4&quot; &quot;MON&quot; &quot;NYA&quot; &quot;NYM&quot; &quot;NYN&quot; &quot;NYY&quot; &quot;OAK&quot; &quot;PHI&quot; &quot;PIT&quot; #&gt; [34] &quot;SDN&quot; &quot;SDP&quot; &quot;SEA&quot; &quot;SFG&quot; &quot;SFN&quot; &quot;SLN&quot; &quot;STL&quot; &quot;TBA&quot; &quot;TBR&quot; &quot;TEX&quot; &quot;TOR&quot; #&gt; [45] &quot;WAS&quot; &quot;WSN&quot; After applying a subset, in order to remove the unused factor levels you need to apply either droplevels(), or else recast your factor as a new factor. For example: sals.2002 &lt;- Salaries [Salaries$yearID==&quot;2002&quot;, ] nl.sals &lt;- sals.2002 [ sals.2002$lgID == &quot;NL&quot;,] levels( nl.sals$teamID ) #&gt; [1] &quot;ANA&quot; &quot;ARI&quot; &quot;ATL&quot; &quot;BAL&quot; &quot;BOS&quot; &quot;CAL&quot; &quot;CHA&quot; &quot;CHC&quot; &quot;CHN&quot; &quot;CHW&quot; &quot;CIN&quot; #&gt; [12] &quot;CLE&quot; &quot;COL&quot; &quot;DET&quot; &quot;FLO&quot; &quot;HOU&quot; &quot;KCA&quot; &quot;KCR&quot; &quot;LAA&quot; &quot;LAD&quot; &quot;LAN&quot; &quot;MIA&quot; #&gt; [23] &quot;MIL&quot; &quot;MIN&quot; &quot;ML4&quot; &quot;MON&quot; &quot;NYA&quot; &quot;NYM&quot; &quot;NYN&quot; &quot;NYY&quot; &quot;OAK&quot; &quot;PHI&quot; &quot;PIT&quot; #&gt; [34] &quot;SDN&quot; &quot;SDP&quot; &quot;SEA&quot; &quot;SFG&quot; &quot;SFN&quot; &quot;SLN&quot; &quot;STL&quot; &quot;TBA&quot; &quot;TBR&quot; &quot;TEX&quot; &quot;TOR&quot; #&gt; [45] &quot;WAS&quot; &quot;WSN&quot; # fix in one of two equivalent ways: # # nl.sals$teamID &lt;- droplevels( nl.sals$teamID ) # nl.sals$teamID &lt;- factor( nl.sals$teamID ) levels( nl.sals$teamID ) #&gt; [1] &quot;ANA&quot; &quot;ARI&quot; &quot;ATL&quot; &quot;BAL&quot; &quot;BOS&quot; &quot;CAL&quot; &quot;CHA&quot; &quot;CHC&quot; &quot;CHN&quot; &quot;CHW&quot; &quot;CIN&quot; #&gt; [12] &quot;CLE&quot; &quot;COL&quot; &quot;DET&quot; &quot;FLO&quot; &quot;HOU&quot; &quot;KCA&quot; &quot;KCR&quot; &quot;LAA&quot; &quot;LAD&quot; &quot;LAN&quot; &quot;MIA&quot; #&gt; [23] &quot;MIL&quot; &quot;MIN&quot; &quot;ML4&quot; &quot;MON&quot; &quot;NYA&quot; &quot;NYM&quot; &quot;NYN&quot; &quot;NYY&quot; &quot;OAK&quot; &quot;PHI&quot; &quot;PIT&quot; #&gt; [34] &quot;SDN&quot; &quot;SDP&quot; &quot;SEA&quot; &quot;SFG&quot; &quot;SFN&quot; &quot;SLN&quot; &quot;STL&quot; &quot;TBA&quot; &quot;TBR&quot; &quot;TEX&quot; &quot;TOR&quot; #&gt; [45] &quot;WAS&quot; &quot;WSN&quot; nl.sals$teamID &lt;- droplevels( nl.sals$teamID ) levels( nl.sals$teamID ) #&gt; [1] &quot;ARI&quot; &quot;ATL&quot; &quot;CHN&quot; &quot;CIN&quot; &quot;COL&quot; &quot;FLO&quot; &quot;HOU&quot; &quot;LAN&quot; &quot;MIL&quot; &quot;MON&quot; &quot;NYN&quot; #&gt; [12] &quot;PHI&quot; &quot;PIT&quot; &quot;SDN&quot; &quot;SFN&quot; &quot;SLN&quot; 2.8 Generating Vectors You will often need to generate vectors for data transformations or simulations. Here are the most common functions that will be helpful. # repeat a number, or series of numbers rep( x=9, times=5 ) #&gt; [1] 9 9 9 9 9 rep( x=c(5,7), times=5 ) #&gt; [1] 5 7 5 7 5 7 5 7 5 7 rep( x=c(5,7), each=5 ) #&gt; [1] 5 5 5 5 5 7 7 7 7 7 rep( x=c(&quot;treatment&quot;,&quot;control&quot;), each=5 ) # also works to create categories #&gt; [1] &quot;treatment&quot; &quot;treatment&quot; &quot;treatment&quot; &quot;treatment&quot; &quot;treatment&quot; #&gt; [6] &quot;control&quot; &quot;control&quot; &quot;control&quot; &quot;control&quot; &quot;control&quot; # create a sequence of numbers seq( from=1, to=15, by=1 ) #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 seq( from=1, to=15, by=3 ) #&gt; [1] 1 4 7 10 13 1:15 # shorthand if by=1 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # create a random sample hat &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;,&quot;f&quot;) sample( x=hat, size=3, replace=FALSE ) #&gt; [1] &quot;b&quot; &quot;a&quot; &quot;f&quot; sample( x=hat, size=3, replace=FALSE ) #&gt; [1] &quot;b&quot; &quot;b&quot; &quot;f&quot; sample( x=hat, size=3, replace=FALSE ) #&gt; [1] &quot;f&quot; &quot;c&quot; &quot;a&quot; # for multiple samples use replacement sample( x=hat, size=10, replace=TRUE ) #&gt; [1] &quot;a&quot; &quot;c&quot; &quot;b&quot; &quot;c&quot; &quot;b&quot; &quot;b&quot; &quot;f&quot; &quot;f&quot; &quot;b&quot; &quot;b&quot; # create data that follows a normal curve iq &lt;- rnorm( n=1000, mean=100, sd=15 ) hist( iq, col=&quot;gray&quot; ) "],
["operators.html", "Chapter 3 Operators 3.1 Datasets 3.2 Subsets 3.3 Variable Transformations 3.4 Missing Values: NA’s 3.5 The ‘attach’ Function", " Chapter 3 Operators Logical operators are the most basic type of data programming and the core of many types of data analysis. Most of the time we are not conducting fancy statistics, we just want to identify members of a group (print all of the females from the study), or describe things that belong to a subset of the data (compare the average price of houses with garages to houses without garages). In order to accomplish these simple tasks we need to use logic statements. A logic statement answers the question, does an observation belong to a group. Many times groups are simple. Show me all of the professions that make over $100k a year, for example. Sometimes groups are complex. Identify the African American children from a specific zip code in Chicago that live in households with single mothers. You will use nine basic logical operators: Operator Description &lt; less than &lt;= less than or equal to &gt; greater than &gt;= greater than or equal to == exactly equal to != not equal to x | y x OR y x &amp; y x AND y ! opposite of Logical operators create logical vectors, a vector that contains only TRUE or FALSE. The TRUE means that the observation belongs to the group, FALSE means it does not. x1 &lt;- c(7,9,1,2) x2 &lt;- c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;) x3 &lt;- c(&quot;treatment&quot;,&quot;control&quot;,&quot;treatment&quot;,&quot;control&quot;) x1 &gt; 7 #&gt; [1] FALSE TRUE FALSE FALSE x1 &gt;= 7 #&gt; [1] TRUE TRUE FALSE FALSE x1 == 9 #&gt; [1] FALSE TRUE FALSE FALSE x1 = 9 # don&#39;t use a single equals operator! it overwrites your variable x1 #&gt; [1] 9 x1 &lt;- c(7,9,1,2) x1 == 9 | x1 == 1 #&gt; [1] FALSE TRUE TRUE FALSE # x2 == male # this will not work because male is not enclosed with quotes x2 == &quot;female&quot; #&gt; [1] FALSE FALSE TRUE TRUE x2 == &quot;female&quot; &amp; x3 == &quot;treatment&quot; #&gt; [1] FALSE FALSE TRUE FALSE Note that we use operators to create logical vectors where TRUE designates observation that belong to the defined group, and FALSE designates observations outside the group. We use these logical vectors in three ways: We can create a selector variable that is used for subsets. When a logical vector is passed to the subset function it will keep all observations with a TRUE value, and drop observations with a FALSE value. x1 #&gt; [1] 7 9 1 2 x1 &gt; 5 #&gt; [1] TRUE TRUE FALSE FALSE keep.these &lt;- x1 &gt; 5 x1[ keep.these ] #&gt; [1] 7 9 # you can create a selector variable with one variable, and apply it to another x2[ keep.these ] # sex of observations where x1 &gt; 5 #&gt; [1] &quot;male&quot; &quot;male&quot; Logical vectors give us an easy way to count things within defined groups. We can apply a sum() function to a logical vector, and the result will be a tally of all of the TRUE cases. # how many females do we have in our study? sum( x2 == &quot;female&quot; ) #&gt; [1] 2 # how many females do we have in our treatment group? sum( x2 == &quot;female&quot; &amp; x3 == &quot;treatment&quot; ) #&gt; [1] 1 We use selector variables to replace observations with new values using the assignment operator. This is similar to a find and replace operation. x7 &lt;- c( &quot;mole&quot;,&quot;mouse&quot;,&quot;shrew&quot;,&quot;mouse&quot;,&quot;rat&quot;,&quot;shrew&quot;) # the lab assistant incorrectly identified the shrews x7 #&gt; [1] &quot;mole&quot; &quot;mouse&quot; &quot;shrew&quot; &quot;mouse&quot; &quot;rat&quot; &quot;shrew&quot; x7[ x7 == &quot;shrew&quot; ] &lt;- &quot;possum&quot; x7 #&gt; [1] &quot;mole&quot; &quot;mouse&quot; &quot;possum&quot; &quot;mouse&quot; &quot;rat&quot; &quot;possum&quot; # we don&#39;t know if linda received the treatment x3 &lt;- c(&quot;adam&quot;,&quot;jamal&quot;,&quot;linda&quot;,&quot;sriti&quot;) x4 &lt;- c( &quot;treatment&quot;,&quot;control&quot;,&quot;treatment&quot;,&quot;control&quot;) x4[ x3 == &quot;linda&quot; ] &lt;- NA x4 #&gt; [1] &quot;treatment&quot; &quot;control&quot; NA &quot;control&quot; The ! operator is a special case, where it is not used to define a new logical vector, but rather it swaps the values of an existing logical vector. x1 #&gt; [1] 7 9 1 2 these &lt;- x1 &gt; 5 these #&gt; [1] TRUE TRUE FALSE FALSE ! these #&gt; [1] FALSE FALSE TRUE TRUE ! TRUE #&gt; [1] FALSE ! FALSE #&gt; [1] TRUE 3.1 Datasets When we combine multiple vectors together, we now have a dataset. There are three main types that we will use in this class. Class Description data frame A typical data set comprised of several variables matrix A data set comprised of only numbers, used for matrix math list The grab bag of data structures - several vectors held together 3.1.1 Data Frames The most familiar spreadsheet-type data structure is called a data frame in R. It consists of rows, which represent observations, and columns, which represent variables. data( USArrests ) dim( USArrests ) # number of rows by number of columns #&gt; [1] 50 4 names( USArrests ) # variable names or column names #&gt; [1] &quot;Murder&quot; &quot;Assault&quot; &quot;UrbanPop&quot; &quot;Rape&quot; row.names( USArrests ) #&gt; [1] &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; #&gt; [5] &quot;California&quot; &quot;Colorado&quot; &quot;Connecticut&quot; &quot;Delaware&quot; #&gt; [9] &quot;Florida&quot; &quot;Georgia&quot; &quot;Hawaii&quot; &quot;Idaho&quot; #&gt; [13] &quot;Illinois&quot; &quot;Indiana&quot; &quot;Iowa&quot; &quot;Kansas&quot; #&gt; [17] &quot;Kentucky&quot; &quot;Louisiana&quot; &quot;Maine&quot; &quot;Maryland&quot; #&gt; [21] &quot;Massachusetts&quot; &quot;Michigan&quot; &quot;Minnesota&quot; &quot;Mississippi&quot; #&gt; [25] &quot;Missouri&quot; &quot;Montana&quot; &quot;Nebraska&quot; &quot;Nevada&quot; #&gt; [29] &quot;New Hampshire&quot; &quot;New Jersey&quot; &quot;New Mexico&quot; &quot;New York&quot; #&gt; [33] &quot;North Carolina&quot; &quot;North Dakota&quot; &quot;Ohio&quot; &quot;Oklahoma&quot; #&gt; [37] &quot;Oregon&quot; &quot;Pennsylvania&quot; &quot;Rhode Island&quot; &quot;South Carolina&quot; #&gt; [41] &quot;South Dakota&quot; &quot;Tennessee&quot; &quot;Texas&quot; &quot;Utah&quot; #&gt; [45] &quot;Vermont&quot; &quot;Virginia&quot; &quot;Washington&quot; &quot;West Virginia&quot; #&gt; [49] &quot;Wisconsin&quot; &quot;Wyoming&quot; head( USArrests ) # print first six rows of the data #&gt; Murder Assault UrbanPop Rape #&gt; Alabama 13.2 236 58 21.2 #&gt; Alaska 10.0 263 48 44.5 #&gt; Arizona 8.1 294 80 31.0 #&gt; Arkansas 8.8 190 50 19.5 #&gt; California 9.0 276 91 40.6 #&gt; Colorado 7.9 204 78 38.7 3.1.2 Matrices A matrix is also a rectangular data object that consists of collections of vectors, but it is special in the sense that it only has numeric vectors and no variable names. mat &lt;- matrix( 1:20, nrow=5 ) mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 6 11 16 #&gt; [2,] 2 7 12 17 #&gt; [3,] 3 8 13 18 #&gt; [4,] 4 9 14 19 #&gt; [5,] 5 10 15 20 names( mat ) #&gt; NULL dim( mat ) #&gt; [1] 5 4 as.data.frame( mat ) # creates variable names #&gt; V1 V2 V3 V4 #&gt; 1 1 6 11 16 #&gt; 2 2 7 12 17 #&gt; 3 3 8 13 18 #&gt; 4 4 9 14 19 #&gt; 5 5 10 15 20 These are used almost exclusively for matrix algebra operations, which are fundamental to mathematical statistics. We will not use matrices in this course. 3.1.3 Lists The list is the most flexible data structure. It is created by sticking a bunch of unrelated vectors or datasets together. For example, when you run a regression you generate a bunch of interesting information. This information is saved as a list. x &lt;- 1:100 y &lt;- 2*x + rnorm( 100, 0, 10) m.01 &lt;- lm( y ~ x ) names( m.01 ) #&gt; [1] &quot;coefficients&quot; &quot;residuals&quot; &quot;effects&quot; &quot;rank&quot; #&gt; [5] &quot;fitted.values&quot; &quot;assign&quot; &quot;qr&quot; &quot;df.residual&quot; #&gt; [9] &quot;xlevels&quot; &quot;call&quot; &quot;terms&quot; &quot;model&quot; m.01$coefficients #&gt; (Intercept) x #&gt; 1.937773 1.967829 m.01$residuals #&gt; 1 2 3 4 5 #&gt; -3.32624659 -4.26993151 3.94723786 -4.38673548 4.39025298 #&gt; 6 7 8 9 10 #&gt; 10.78851222 -2.92382113 -10.33417022 -3.68479590 -0.92645854 #&gt; 11 12 13 14 15 #&gt; 7.99065717 11.81920770 13.89950917 -20.85387992 -14.07278078 #&gt; 16 17 18 19 20 #&gt; -7.47178718 8.19228260 10.79007939 19.24931842 -2.22019795 #&gt; 21 22 23 24 25 #&gt; -14.06851755 -17.52937857 11.90462585 2.55792227 -3.23311341 #&gt; 26 27 28 29 30 #&gt; -10.93639444 -12.21493400 3.90430680 8.03016308 3.35117463 #&gt; 31 32 33 34 35 #&gt; 8.43937367 5.86751597 -8.65846780 -6.33127530 -0.77414257 #&gt; 36 37 38 39 40 #&gt; 12.59616391 -6.36991914 6.73458172 2.40175121 -4.08102106 #&gt; 41 42 43 44 45 #&gt; 16.72942570 -4.94229932 -2.78266362 9.47348078 -15.13323309 #&gt; 46 47 48 49 50 #&gt; -16.96493154 5.34541943 2.93456049 3.81652838 0.26932558 #&gt; 51 52 53 54 55 #&gt; -3.71958696 -8.08763393 -12.72340244 8.27982707 -12.22895432 #&gt; 56 57 58 59 60 #&gt; 0.53272892 0.50967596 -3.04176536 13.35899674 -7.98409949 #&gt; 61 62 63 64 65 #&gt; -12.00801424 -9.19451194 3.66820814 -3.13298211 2.03077610 #&gt; 66 67 68 69 70 #&gt; 2.70661546 -5.33416408 9.91642209 8.90927937 12.52383708 #&gt; 71 72 73 74 75 #&gt; 22.94437337 17.53486005 -0.93944708 -15.04130806 7.72075044 #&gt; 76 77 78 79 80 #&gt; -10.10107154 0.82038259 1.61422605 5.46957962 8.12359934 #&gt; 81 82 83 84 85 #&gt; 1.95817862 0.95309260 -0.08883241 6.44239118 -1.57854693 #&gt; 86 87 88 89 90 #&gt; 6.95846790 23.67767162 5.81232148 -9.05385141 -7.90242325 #&gt; 91 92 93 94 95 #&gt; -4.43828300 6.62558022 3.88194220 -2.34736711 -6.27696621 #&gt; 96 97 98 99 100 #&gt; -15.95553411 -13.40072724 6.16552110 -16.57342286 -4.91868960 m.01$call #&gt; lm(formula = y ~ x) These output are all related to the model we have run, so they are kept organized by the list so they can be used for various further steps like comparing models or checking for model fit. A data frame is a bit more rigid that a list in that you cannot combine elements that do not have the same dimsions. # new.dataframe &lt;- data.frame( m.01$coefficients, m.01$residuals, m.01$call ) # # these will fail because the vectors have different lengths 3.2 Subsets The subset operators [ ] are one of the most common you will use in R. The primary rule of subsets is to use a data operator to create a logical selector vector, and use that to generate subsets. Any observation that corresponds to TRUE will be retained, any observation that corresponds to FALSE will be dropped. For vectors, you need to specify a single dimension. x1 &lt;- c(167,185,119,142) x2 &lt;- c(&quot;adam&quot;,&quot;jamal&quot;,&quot;linda&quot;,&quot;sriti&quot;) x3 &lt;- factor( c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;) ) x4 &lt;- c( &quot;treatment&quot;,&quot;control&quot;,&quot;treatment&quot;,&quot;control&quot; ) dat &lt;- data.frame( name=x2, sex=x3, treat=x4, strength=x1 ) these &lt;- x1 &gt; 140 # selector vector these #&gt; [1] TRUE TRUE FALSE TRUE x1[ these ] #&gt; [1] 167 185 142 x2[ these ] #&gt; [1] &quot;adam&quot; &quot;jamal&quot; &quot;sriti&quot; For data frames, you need two dimensions (rows and columns). The two dimensions are seperated by a comma, and if you leave one blank you will not drop anything. # dat[ row position , column position ] dat #&gt; name sex treat strength #&gt; 1 adam male treatment 167 #&gt; 2 jamal male control 185 #&gt; 3 linda female treatment 119 #&gt; 4 sriti female control 142 these &lt;- dat$treat == &quot;treatment&quot; dat[ these , ] # all data in the treatment group #&gt; name sex treat strength #&gt; 1 adam male treatment 167 #&gt; 3 linda female treatment 119 dat[ , c(&quot;name&quot;,&quot;sex&quot;) ] # select two columns of data #&gt; name sex #&gt; 1 adam male #&gt; 2 jamal male #&gt; 3 linda female #&gt; 4 sriti female # to keep a subset as a separate dataset dat.women &lt;- dat[ dat$sex == &quot;female&quot; , ] dat.women #&gt; name sex treat strength #&gt; 3 linda female treatment 119 #&gt; 4 sriti female control 142 Note the rules listed above about subsetting factors. After applying a subset, they will retain all of the original levels, even when they are not longer useful. You need to drop the unused levels if you would like them to be omitted from functions that use the factor levels for analysis. df &lt;- data.frame( letters=LETTERS[1:5], numbers=seq(1:5) ) levels( df$letters ) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; sub.df &lt;- df[ 1:3, ] sub.df$letters #&gt; [1] A B C #&gt; Levels: A B C D E levels( sub.df$letters ) #&gt; [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; droplevels( sub.df$letters ) #&gt; [1] A B C #&gt; Levels: A B C sub.df$letters &lt;- droplevels( sub.df$letters ) 3.3 Variable Transformations When we create a new variable from existing variables, it is called a ‘transformation’. This is very common in data science. Crime is measures by the number of assults per 100,000 people, for example (crime / pop). A batting average is the number of hits divided by the number of at bats. In R, mathematical operations are vectorized, which means that operations are performed on the entire vector all at once. This makes transformations fast and easy. x &lt;- 1:10 x + 5 #&gt; [1] 6 7 8 9 10 11 12 13 14 15 x * 5 #&gt; [1] 5 10 15 20 25 30 35 40 45 50 R uses a convention called “recycling”, which means that it will re-use elements of a vector if necessary. In the example below the x vector has 10 elements, but the y vector only has 5 elements. When we run out of y, we just start over from the beginning. This is powerful in some instances, but can be dangerous in others if you don’t realize that that it is happening. x &lt;- 1:10 y &lt;- 1:5 x + y #&gt; [1] 2 4 6 8 10 7 9 11 13 15 x * y #&gt; [1] 1 4 9 16 25 6 14 24 36 50 # the colors are recycled plot( 1:5, 1:5, col=c(&quot;red&quot;,&quot;blue&quot;), pch=19, cex=3 ) Here is an example of recycling gone wrong: x1 &lt;- c(167,185,119,142) x2 &lt;- c(&quot;adam&quot;,&quot;jamal&quot;,&quot;linda&quot;,&quot;sriti&quot;) x3 &lt;- c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;female&quot;) x4 &lt;- c( &quot;treatment&quot;,&quot;contro&quot;,&quot;treatment&quot;,&quot;control&quot; ) dat &lt;- data.frame( name=x2, sex=x3, treat=x4, strength=x1 ) # create a subset of data of all female study participants dat$sex == &quot;female&quot; #&gt; [1] FALSE FALSE TRUE TRUE these &lt;- dat$sex == &quot;female&quot; dat[ these, ] # correct subset #&gt; name sex treat strength #&gt; 3 linda female treatment 119 #&gt; 4 sriti female control 142 # same thing, but i mess is up - the female element is recycled in the overwrite dat$sex = &quot;female&quot; # whoops just over-wrote my data! should be double equal these &lt;- dat$sex == &quot;female&quot; dat[ these , ] #&gt; name sex treat strength #&gt; 1 adam female treatment 167 #&gt; 2 jamal female contro 185 #&gt; 3 linda female treatment 119 #&gt; 4 sriti female control 142 3.4 Missing Values: NA’s Missing values are coded differently in each data analysis program. SPSS uses a period, for example. In R, missing values are coded as “NA”. The important thing to note is that R wants to make sure you know there are missing values if you are conducting analysis. As a result, it will give you the answer of “NA” when you try to do math with a vector that includes a missing value. You have to ask it explicitly to ignore the missing value. x5 &lt;- c( 1, 2, 3, 4 ) x5 #&gt; [1] 1 2 3 4 sum( x5 ) #&gt; [1] 10 mean( x5 ) #&gt; [1] 2.5 x5 &lt;- c( 1, 2, NA, 4 ) x5 #&gt; [1] 1 2 NA 4 # should missing values be treated as zeros or dropped? sum( x5 ) #&gt; [1] NA mean( x5 ) #&gt; [1] NA sum( x5, na.rm=T ) # na.rm=T argument drops missing values #&gt; [1] 7 mean( x5, na.rm=T ) # na.rm=T argument drops missing values #&gt; [1] 2.333333 You cannot use the == operator to identify missing values in a dataset. There is a special is.na() function to locate all of the missing values in a vector. x5 #&gt; [1] 1 2 NA 4 x5 == NA # this does not do what you want #&gt; [1] NA NA NA NA is.na( x5 ) # much better #&gt; [1] FALSE FALSE TRUE FALSE ! is.na( x5 ) # if you want to create a selector vector to drop missing values #&gt; [1] TRUE TRUE FALSE TRUE x5[ ! is.na(x5) ] #&gt; [1] 1 2 4 x5[ is.na(x5) ] &lt;- 0 # replace missing values with zero 3.5 The ‘attach’ Function Never Use This! This is a convenient function for making variable names easily accessible, but it is problematic because of: scope conflicting variable names x &lt;- 1:5 y &lt;- 6:10 dat &lt;- data.frame(x,y) rm(x) rm(y) # I want to transform x in my dataset attach( dat ) 2*x #&gt; [1] 2 4 6 8 10 x &lt;- 2*x detach( dat ) x #&gt; [1] 2 4 6 8 10 dat # whoops! I didn&#39;t save my work in the dataset #&gt; x y #&gt; 1 1 6 #&gt; 2 2 7 #&gt; 3 3 8 #&gt; 4 4 9 #&gt; 5 5 10 You will see the attach() function used on occassion, and it is tempting because you can write the variable names directly. But in general, try to avoid the attach() function and don’t form bad habits by using it now because when your scripts become more complicated then can cause problmes. "]
]
